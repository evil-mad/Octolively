/*
 Title:			 lifenew.c
 Author:		 Windell Oskay
 Date Created:   2/20/12
 Last Modified:  3/5/12
 Purpose: Interactive Conway's Game of Life
 Target: ATmega164P
 
 Hardware: Octolively PCB with 16 MHz crystal oscillator.
 Fuse settings: 16 MHz clock speed
 
 
 Board orientation:  J4 is "north"
 
	   NORTH
       
     ___J4___
    |        |
    | O    O |
W   |        |   E
E   | O    O |   A
S  J3        J1  S
T   | O    O |   T
    |        |
    | O    O |
    |___J2___|
 
       SOUTH
 
 
 Analog inputs:    PA0 - PA7
 IR LED Outputs:   PC0 - PC7
 Vis. LED Outputs: PD0 - PD7
 
 Communcation: 
 Broadcast output (To J1-J4): PB0 
 Edge inputs (From J1 - J4): PB1 - PB4, respectively 
 (These are also PCINT9 - PCINT12, respectively)
 
 
 Sync signal is generated by SE-most board (lower right board in a grid),
 and transmitted North and West.

 Command inputs (if any) are transmitted South and East to the "master" board.
 
 Timing is via Timer 1, running at ClkIO/256, giving a 62.5 kHz tick, and 16 us steps. 
 
 */




//Uncomment one of the following lines to hard-code the "Step/Run" PCB or the "Pause/Clear" PCB.
// Note that these HARD-CODE the response function-- it cannot be changed through menus or EEPROM if you compile this in.


//#define   StepRunBoard 1
//#define	PauseClearBoard 1
 
 

// Enable for debugging only: 
// Turns on certain "stop" points, with LEDs to indicate position.
//#define  DebugAlerts 1


#include <avr/io.h> 
#include <avr/interrupt.h>
#include <stdlib.h>
#include <avr/eeprom.h> 
 
// Communication Inputs: Pins PB1, PB2, PB3, PB4.
// Input mask: 2 + 4 + 8 + 16 = 
#define	ComInputMask 30U  

// Inputs from South, East sides only: 
// Inputs: Pins PB1, PB2.
// Input mask: 2 + 4 
#define	ComInputMaskSE 6U

#define	ComOutputMask 1U

#define nEast 2
#define nSouth 4        
#define nWest 8          
#define nNorth 16    
 

// Different behavior for "controller" boards:
// Either the step/play
// or pause/clear buttons


 
 
// Global variables:

uint8_t LEDstate;	// "off-screen" buffer, used to prep data for PORTD.

uint8_t OutputCmdNW; 

uint8_t neighborNorth;
uint8_t neighborSouth;
uint8_t neighborEast;
uint8_t neighborWest;

uint8_t LEDgrid[24];

uint8_t OutputCmdSE;
uint8_t OutputCmdSELast;
uint8_t ControlBoard;
   
uint8_t buttonMonitor, buttonMonitorLast;

uint8_t initialized[8];  // Are cells initialized?

unsigned int NextEventTime;


int BrightScanTotal[8];
int DarkScanTotal[8];
 

void setup(void);
void loop(void);
void DoADCscan(void);


// Configuration Variables, stored in EEPROM:

// Board type: 0: display. 1: Step/Play buttons. 2: Pause/Clear buttons. 
// Board Rank: 0: Auto detect.  1: Force Master.  2: Force Caboose. 
// Random Fill Config: 0: After 60 s idle.  1: After 15 s idle.  2: Disabled. 
// Step speed (at turn-on): 0: 1 Hz.  1: 2 Hz  2: 4 Hz. 

#define DEFAULT_BoardType 0
#define DEFAULT_BoardRank 0
#define DEFAULT_RandomConfig 0
#define DEFAULT_StepSpeed 0

uint8_t  BoardType; 
uint8_t  BoardRank;
uint8_t  RandomConfig;
uint8_t  StepSpeed;

uint8_t EEMEM EEBoardType = DEFAULT_BoardType; 	 
uint8_t EEMEM EEBoardRank = DEFAULT_BoardRank;
uint8_t EEMEM EERandomConfig = DEFAULT_RandomConfig;
uint8_t EEMEM EEStepSpeed = DEFAULT_StepSpeed;

 
void DoADCscan(void)
{
    
    uint8_t channel, brightchannel;    
    
    uint8_t scan = 0;
    
    uint8_t index = 0;
    
    while (index < 8) {
        BrightScanTotal[index] = 0;
        DarkScanTotal[index] = 0;
        
        index++;
    }
     
    while (scan < 15){
        
        channel = 0;
        while (channel < 8) {
            
            
            brightchannel = channel + 2;
            if (brightchannel > 7) {
                brightchannel -= 8;		// wraparound!
            }
            
            PORTC = 1 << brightchannel;		// Turn on IR LED at channel + 2.
            
            NextEventTime += 3;  // Allow 3 ticks settling time after changing IR LED position.
            
            while (TCNT1 < NextEventTime) {  asm("nop");   }  
            
            ADMUX = channel;	
            ADCSRA |= _BV(ADSC);	// Start ADC, on DARK channel.	
             
            if (( PINB & _BV(5)) == 0) 
                buttonMonitor = 0;  
             
            while (ADCSRA & _BV(ADSC)) {
                ;;	// wait for ADC to finish.  This takes about 104 microseconds, or 6.5 "ticks" of TCNT1.
            }
            
            DarkScanTotal[channel] += ADCW;	// Add result to dark total.
            
            ADMUX = brightchannel;	
            ADCSRA |= _BV(ADSC);	// Start ADC, on BRIGHT channel.	
             
            if (( PINB & _BV(5)) == 0) 
                buttonMonitor = 0;  
             
            while (ADCSRA & _BV(ADSC)) {
                ;;	// wait for ADC to finish.  This takes about 104 microseconds, or 6.5 "ticks" of TCNT1.
            }
            BrightScanTotal[brightchannel] += ADCW;	// Add result to bright total.		
            
            
            NextEventTime += 14;  // Allow 14 ticks for the two ADC conversions.
            
            
#ifdef DebugAlerts
            if (TCNT1 > NextEventTime) { 
                
                PORTD = 34;
                while (1) {
                    ;;
                }
            } 
#endif 
            
            while (TCNT1 < NextEventTime) {  asm("nop");   }  
             
            channel++;
        }		
        
        scan++;
    }
    
    PORTC = 1 << 2;	// DO NOT Turn off all IR LEDs.  It leads to a visible flicker in the visible LEDs, as the power supply suddenly jumps up a bit!
    
}
 
int main (void)
{ 
	setup();
	loop();
	return 0;
}

void setup() {
	asm("cli");		// DISABLE global interrupts
	  
	
	uint8_t inputTemp;
	
	DDRB  = ComOutputMask; // All B Inputs except for pin PB0, our output.
	PORTB = ComOutputMask | ComInputMask;		// Pull-ups on input lines, output line high to start.
	
	DDRA  = 0; // All A Inputs
	PORTA = 0;
	 
	DDRC  = 255; // All C outputs to IR LEDs
	PORTC = 0;
	
	DDRD  = 255; // All D outputs to visible LEDs 
	LEDstate = 0;
     
	PORTD = LEDstate;
  
    
    
	PCMSK1 = ComInputMaskSE; // Pin change interrupt mask, on SE inputs only
	//PCICR = 2; // Enable PCINTs on PCMSK1
	
    
    
	//16-bit Timer 1 setup	
	 
	TCCR1A = 0;	// Timer outputs disconnected, no waveform generation.
	TCCR1B = _BV(CS12);  //Prescale Timer1 by 256, giving 62.5 kHz from 16 MHz.	
	TCCR1C = 0;	// No force compare
     
	  
	
	// ADC setup:
	ADCSRA = _BV(ADEN) |_BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0);
	// Enable ADC, prescale by 128, so ADC clock is 125 kHz.  
	
    
    // Run initial ADC scan now, becaues the first ADC scan takes longer than usual.
    
    ADMUX = 0;	
    ADCSRA |= _BV(ADSC);	// Start ADC
     
    while (ADCSRA & _BV(ADSC)) {
        ;;	// wait for ADC to finish.   
    }
    
    
    
	 
	// Basic Initializations:
	
	uint8_t i = 0;
	while (i < 24) {
		LEDgrid[i] = 0;
		i++;
	}
	
	OutputCmdNW = 0;
	OutputCmdSE = 0;
    OutputCmdSELast = 0;
    
	neighborNorth = 0;
	neighborSouth = 0;
	neighborEast = 0;
	neighborWest = 0;
	 
	StepSpeed = 0;
	
    ControlBoard = 0;
 
	
 // Identify our neighbors:
 // Take output pin low for 3 seconds.  During this time, check to see if any of our com inputs also go low.	
 // If so, we have a neighbor on that side.
	 
	inputTemp = 255;
	
	
	TCNT1 = 0;	// Set counter value at 0 to begin with.
	PORTB &= 254;   // Set ComOutputMask pin low; broadcast zero. 
	
	while (TCNT1 < 62500) { // One second with outputs low
		inputTemp &= PINB;
	} 
	 
     PORTB = 255;  // Take broadcast pin high again.
    
    
    
    // Read configuration variables from EEPROM:
    BoardType = eeprom_read_byte(&EEBoardType);
    BoardRank = eeprom_read_byte(&EEBoardRank);
    RandomConfig = eeprom_read_byte(&EERandomConfig);
    StepSpeed = eeprom_read_byte(&EEStepSpeed);
    
    // Check (and correct) for potential EEPROM correction:
    
    
    if (BoardType > 2) 
        BoardType = DEFAULT_BoardType;
    if (BoardRank > 2) 
        BoardRank = DEFAULT_BoardRank;
    if (RandomConfig > 2) 
        RandomConfig = DEFAULT_RandomConfig;
    if (StepSpeed > 2) 
        StepSpeed = DEFAULT_StepSpeed;
    
      
    
    
    //  Pin PB5 is our "button" input.
    
    if (( PINB & (_BV(5))) == 0) {
        // If button is held down at turn-on time....
        
        
/*        Configuration menu Setup
 
 
  LED positions
 
           E
     ________________
    | D0  D1  D2  D3 |  
 N	|                |  S
    | D4  D5  D6  D7 |  
    |________________|
     
           W
 
                         |                    BOTTOM ROW (Select Menu Item)                  |
      TOP ROW            |                                                                   |       
    (Menu name)          |       D4       |       D5       |       D6       |       D7       |
 ------------------------+----------------+----------------+----------------+----------------|
 D0: Board Type          |     Display    |   Step/Play    |   Pause/Clear  |       -        |
                         |                |                |                |                |
 D1: Board Rank          |    Auto Detect |  Force Master  |  Force Caboose |       -        |
                         |                |                |                |                |
 D2: Random Fill Config  | After idle 60s | After idle 15s |    Disabled    |       -        |
                         |                |                |                |                |
 D3: Turn-on Step Speed  |     1 Hz       |      2 Hz      |      4 Hz      |       -        |
                         |                |                |                |                |
 D0 + D1 + D2 + D3       |  Back to D0... |       -        |       -        |  SAVE & EXIT   | 
 
 
 HOLD the button for 1 second to cycle through the five menus:
 D0: Board type
 D1: Board Rank
 D2: Random Fill Config
 D3: Turn-on Step Speed
 and
 D0-D3, back to beginning of menu, or save & exit
          
 Within each menu, press and release the button to cycle 
 
  */      

        // Light up first Menu, "board type," with current value
        PORTD = 1 | (1 << (BoardType + 4));
        
        while ( (PINB & _BV(5)) == 0) {
            // Wait for button to be released
        }

        uint8_t input = 1;
        uint8_t inputLast = 1;
        uint8_t menu = 0;
        uint8_t menuselection = BoardType;
        uint8_t exitmenu = 0;
        uint8_t waitforrelease = 0;

         
        
        TCNT1 = 0; 
        
        while (exitmenu == 0) {
          
            if (menu == 4) { 
                PORTD = 15 | (1 << (3 * menuselection + 4));  
            }   
            else{
                PORTD = (1 << menu) | (1 << (menuselection + 4));  
            }
            
            
            
            if ( PINB & _BV(5)) 
                input = 1; 
            else 
                input = 0;
             
            
            if ((input == 0) && (inputLast)) {
                // Button was just pressed.
                
                TCNT1 = 0; 
            }
            
            if ((input == 0) && (inputLast == 0)) {
                
                // Button has been held down for AT LEAST 1 s.
                if (TCNT1 > 62500) { 
                    TCNT1 = 62500;
                    
                    if (waitforrelease == 0) {
                        
                     waitforrelease = 1;	// 
                    
                    // Advance menu 
                    if (menu == 0) {
                        BoardType = menuselection;
                        menu = 1; 
                        menuselection = BoardRank; 
                    }
                    else if (menu == 1) {
                       BoardRank = menuselection;
                        menu = 2;
                        menuselection = RandomConfig; 
                    }           
                    else if  (menu == 2) {
                        RandomConfig = menuselection;
                        menu = 3;
                        menuselection = StepSpeed;
                    }               
                    else if  (menu == 3) {
                        StepSpeed = menuselection;
                        menu = 4;
                        menuselection = 0;
                    }               
                    else {  //(menu == 4)  
                        if (menuselection == 0){
                            menu = 0;
                            menuselection = BoardType;
                        }
                        else { // Save & exit
                            exitmenu = 1; 
                        } 
                    } 
                  }
                }  
            }        
             
            
            
            
            if ((input == 1) && (inputLast == 0)){
            
            // Button just released
            
                if (waitforrelease == 0) {
                    //If we were waiting for the button to be released, then we have ALREADY acted on its being held down.
                    //So, do not do anything.
                    //But, if the button were released sooner than 1 second after being pressed, let's act on it:
                    
                    if (TCNT1 > 3125) {  //Debounce: If the button had been down for at least (1/20) second...
                        
                        menuselection++;
                        
                        if (menu == 4) { 
                           if (menuselection > 1) 
                               menuselection = 0; 
                        }   
                        else{
                            if (menuselection > 2) 
                                menuselection = 0; 
                        } 
                    } 
                } 
                waitforrelease = 0;
            }
            
             
            
            
            inputLast = input;
            
        }
        
        buttonMonitor  = 1;
        buttonMonitorLast = 1;
        
        
        
        // TODO: Save EEPROM HERE
         
        
        PORTD = 0;  
        TCNT1 = 0;
        while (TCNT1 < 15625) { // 250 ms delay
        } 
        
        eeprom_write_byte(&EEBoardType, BoardType); 
        eeprom_write_byte(&EEBoardRank, BoardRank); 
        eeprom_write_byte(&EERandomConfig, RandomConfig); 
        eeprom_write_byte(&EEStepSpeed, StepSpeed); 
         
        TCNT1 = 0;
        while (TCNT1 < 15625) { // 250 ms delay
        } 
        
        
        PORTD = 255; 
        TCNT1 = 0;
        while (TCNT1 < 15625) { // 250 ms bright flash
        } 
        PORTD = 0;  
         
        TCNT1 = 0;
        while (TCNT1 < 31250) { // 500 ms delay
        } 
        
    }
    
    
    
    
    
	/*		
       NORTH		
	 ___J4___
	 |        |
	 | O    O |
 W   |        |   E
 E   | O    O |   A
 S  J3        J1  S
 T   | O    O |   T
	 |        |
	 | O    O |
	 |___J2___|
       SOUTH 
	 Edge inputs (From J1 - J4): PB1 - PB4, respectively 
	 
	 */	
     
    if ((inputTemp & nEast) == 0) {
	   neighborEast = 1;
    } 
    if ((inputTemp & nSouth) == 0) {
		neighborSouth = 1;
	}
	if ((inputTemp & nWest) == 0) {
		neighborWest = 1;
	}
	if ((inputTemp & nNorth) == 0) {
		neighborNorth = 1;
	}
    
    
    if (BoardRank == 0) {
        // If we are Auto Detecting the board rank...
    
        
        if ((neighborNorth + neighborWest) == 0) {
            BoardRank = 2;  // "Caboose Board"
            LEDstate = 16;
        }	
         
        if ((neighborSouth + neighborEast) == 0) {
            BoardRank = 1; // "Master board"
            LEDstate = 8;
        }	
    
    } 
     
    
    if (LEDstate == 0) {
        LEDstate = 129;  // Not master or caboose
    }
     
	
    PORTD = LEDstate;
     
    TCNT1 = 0;
    
	while (TCNT1 < 62500) { 
		inputTemp &= PINB;			// One second with outputs high
	} 
     
      TCNT1 = 0;
    
    
    
#ifdef	StepRunBoard 
    BoardType = 1;
#endif
    
#ifdef	PauseClearBoard
    BoardType = 2;
#endif
     
    
    if (BoardType > 0) {
        ControlBoard = 1;
    }
    
    
    if( BoardRank == 1 )
    {
        // Master board!
        
        while (TCNT1 < 15624)		// 250 ms
        {  asm("nop");   }
        TCNT1 = 0;	// Set counter value at 0 to begin with.
        PORTB &= 254;   // Set ComOutputMask pin low; broadcast zero. 
        
    }   
    else
    { 
        while ((PINB & ComInputMaskSE) == ComInputMaskSE)
            
        {
#ifdef DebugAlerts
            if (TCNT1 > 50000) {		// Should never get here!
                PORTD = 4+32+128;
                while (1) { ;; }
            } 
#endif  
        }
        
        TCNT1 = 0;	// Set counter value at 0 to begin cycle.
        PORTB &= 254;   // Set ComOutputMask pin low; broadcast zero. 
         
    }   
    
    
     
}




void loop() {  // Infinite loop section
    uint8_t i = 0;  // Dummy variables for indices
    uint8_t tmp, tmp2;  // Dummy variables (general purpose)
    
    uint8_t NewLEDstate = 0;
    unsigned int tempU;
    
    int tempInt;
    unsigned int SignalLevel[8];
    
    unsigned int SignalMax[8];
    unsigned int SignalMin[8];
    unsigned int SignalMinNew[8];
    uint8_t SignalMinCycleCount = 0;
    
    unsigned int thresholdHigh, thresholdLow;
    
    int8_t DebounceCounter[8];
    
    uint8_t CtrlBlink = 0;
    
    uint8_t OutputCmdSEn, OutputCmdSEw;
    
    uint8_t RunMode = 1;			
    uint8_t idleCount = 0;
    
    uint8_t localIdle = 0;
    uint8_t LEDstateLast = 0;
    uint8_t LEDstateLast2 = 0;      
    
    
	uint8_t DriftSequenceLength ;
	int8_t DebounceDuration ;
         
    uint8_t buttonTimer = 0;
   // uint8_t input = 1;
  //  uint8_t inputLast = 1;
    
    uint8_t waitforrelease = 0;
    
    i = 0;
    while (i < 8) {
        DebounceCounter[i] = 0;
        SignalMax[i] = 0;
        SignalMin[i] = 65535;
        SignalMinNew[i] = 65535;
        initialized[i] = 0;
        i++;
        
    }
    
    
    while (1){ // A fixed 250 ms sequence
 
        PCICR = 0;  // Disable pin change interrupt
         
        
		// Manage sync pulse
		if (BoardRank == 1) {  // If this is the Master board
			tmp = 3 * ( 1 + OutputCmdNW);  // Time to end sync pulse
			
			while (TCNT1 < tmp) { 
				asm("nop");  	
			}
			
			PORTB |= ComOutputMask; // End signal pulse
			
		}
		else { // Follower Boards:
			tmp = 0;
			
             
			
			
			if (neighborEast) {
				if ((PINB & nEast) == 0) 
				tmp |= nEast;
			}		
			
			if (neighborSouth) {
				if ((PINB & nSouth) == 0) 
				tmp |= nSouth;
			}
	
			if (tmp > 0) {
				
				while ((PINB & tmp) == 0) { 
					asm("nop");  	
				} 
				
				PORTB |= ComOutputMask; // End signal pulse
				tempU = TCNT1;
				
				if (tempU <= 4) {
					OutputCmdNW = 0;
				}
				else if (tempU <= 7){
					OutputCmdNW = 1; 
				}
				else if (tempU <= 10){
					OutputCmdNW = 2; 
				}
				else if (tempU <= 14){
					OutputCmdNW = 3; 
				} 
			} 
		}

		// Prep broadcast data
		// We send data from BEFORE the Life-Step, if a step is occurring.
		 
		/*
		 
	   GRID ORDER:
		              E
		 
		 0      1   2   3    4    5
		       ________________
	     6    | 7   8   9   10 |  11
	N	      |                |         S
		 12   | 13  14  15  16 |  17
			  |________________|
		 18     19  20  21  22    23
		 
		              W
		 
		 7-10,13-16 map to positions 0-7 on the LED grid.
		  
		 
    Broadcast "East" :  7,  8,  9, 10    Receive "from West" : 19, 20, 21, 22
    Broadcast "West" : 13, 14, 15, 16	 Receive "from East" :  1,  2,  3,  4
    Broadcast "South":  4, 10, 16, 22	 Receive "from North":  0,  6, 12, 18	 
    Broadcast "North":  1,  7, 13, 19	 Receive "from South":  5, 11, 17, 23     
         
    Four digits are Broadcast twice.  So, simplify this to:     
		 
	Broadcast "East" :  7,  8,  9, 10    Receive "from West" : (11-S,19-W), 20, 21, (6-N,22-W)
    Broadcast "West" : 13, 14, 15, 16	 Receive "from East" : (1-E,17-S), 2, 3, (4-E,12-N)
	Broadcast "South":  4, 22			 Receive "from North":  0, 18	 
	Broadcast "North":  1, 19			 Receive "from South":  5, 23 
         
    These 12 bits are followed by OutputCmdSE, low bit (first) then high bit.
		 */
		
        i = 0;
        while (i < 24) {
            LEDgrid[i] = 0;
            i++;
        }
        
        
        if (ControlBoard == 0) {
            
         // Load LED state values into "network" grid array:
        LEDgrid[7]  = (LEDstate & _BV(0)) != 0;
        LEDgrid[8]  = (LEDstate & _BV(1)) != 0;
        LEDgrid[9]  = (LEDstate & _BV(2)) != 0;
        LEDgrid[10] = (LEDstate & _BV(3)) != 0;
        LEDgrid[13] = (LEDstate & _BV(4)) != 0;
        LEDgrid[14] = (LEDstate & _BV(5)) != 0;
        LEDgrid[15] = (LEDstate & _BV(6)) != 0;
        LEDgrid[16] = (LEDstate & _BV(7)) != 0;
        }
        
		NextEventTime = 14;				//Starting time, in ticks, of data broadcast
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Wait until start time
        
        // FIRST BROADCAST ROW
        
        if (LEDgrid[7]) 
            PORTB &= 254;   // Set ComOutputMask pin low, to broadcast a TRUE signal, if the LEDgrid[7] is high.
        else 
            PORTB |= 1; 
        NextEventTime += 2;
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Midpoint of bit: do readout
        if ((PINB & nWest) == 0)
            LEDgrid[19] = 1;   
        if ((PINB & nSouth)  == 0)
            LEDgrid[11] = 1;    
        
        NextEventTime += 2;  
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Wait until start time
        if (LEDgrid[8]) 
            PORTB &= 254;   // Set ComOutputMask pin low, to broadcast a TRUE signal, if the LEDgrid[] pin is high.
        else 
            PORTB |= 1; 
        NextEventTime += 2;
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Midpoint of bit: do readout
        if ((PINB & nWest) == 0)
            LEDgrid[20] = 1;   
        
        NextEventTime += 2; 
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Wait until start time
        if (LEDgrid[9]) 
            PORTB &= 254;   // Set ComOutputMask pin low, to broadcast a TRUE signal, if the LEDgrid[] pin is high.
        else 
            PORTB |= 1; 
        NextEventTime += 2;
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Midpoint of bit: do readout
        if ((PINB & nWest)  == 0)
            LEDgrid[21] = 1;   
            
        NextEventTime += 2; 
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Wait until start time     
        if (LEDgrid[10]) 
            PORTB &= 254;   // Set ComOutputMask pin low, to broadcast a TRUE signal, if the LEDgrid[] pin is high.
        else 
            PORTB |= 1; 
        NextEventTime += 2;
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Midpoint of bit: do readout
        if ((PINB & nWest)  == 0)
            LEDgrid[22] = 1;   
        if ((PINB & nNorth)  == 0)
            LEDgrid[6] = 1;           
        
        // SECOND BROADCAST ROW
   
        NextEventTime += 2; 
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Wait until start time   
        if (LEDgrid[13]) 
            PORTB &= 254;   // Set ComOutputMask pin low, to broadcast a TRUE signal, if the LEDgrid[] pin is high.
        else 
            PORTB |= 1; 
        NextEventTime += 2;
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Midpoint of bit: do readout
        if ((PINB & nEast) == 0)
            LEDgrid[1] = 1;   
        if ((PINB & nSouth) == 0)
            LEDgrid[17] = 1;   
        
        NextEventTime += 2;  
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Wait until start time
        if (LEDgrid[14]) 
            PORTB &= 254;   // Set ComOutputMask pin low, to broadcast a TRUE signal, if the LEDgrid[] pin is high.
        else 
            PORTB |= 1; 
        NextEventTime += 2;
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Midpoint of bit: do readout
        if ((PINB & nEast) == 0)
            LEDgrid[2] = 1;   
        
        NextEventTime += 2; 
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Wait until start time
        if (LEDgrid[15])
            PORTB &= 254;   // Set ComOutputMask pin low, to broadcast a TRUE signal, if the LEDgrid[] pin is high.
        else 
        	PORTB |= 1; 
        NextEventTime += 2;
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Midpoint of bit: do readout
        if ((PINB & nEast)  == 0)
            LEDgrid[3] = 1;   
        
        NextEventTime += 2; 
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Wait until start time     
        if (LEDgrid[16]) 
            PORTB &= 254;   // Set ComOutputMask pin low, to broadcast a TRUE signal, if the LEDgrid[] pin is high.
        else 
        	PORTB |= 1; 
        NextEventTime += 2;
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Midpoint of bit: do readout
        if ((PINB & nEast) == 0)
            LEDgrid[4] = 1;   
        if ((PINB & nNorth) == 0)
            LEDgrid[12] = 1;        
        
        
        // THIRD BROADCAST ROW
         
        NextEventTime += 2;  
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Wait until start time
        if (LEDgrid[4]) 
        	PORTB &= 254;   // Set ComOutputMask pin low, to broadcast a TRUE signal, if the LEDgrid[] pin is high.
        else 
            PORTB |= 1; 
        NextEventTime += 2;
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Midpoint of bit: do readout
        if ((PINB & nNorth) == 0)
        	LEDgrid[0] = 1;   
        
        NextEventTime += 2; 
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Wait until start time
        if (LEDgrid[22]) 
        	PORTB &= 254;   // Set ComOutputMask pin low, to broadcast a TRUE signal, if the LEDgrid[] pin is high.
        else 
            PORTB |= 1;             
        NextEventTime += 2;
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Midpoint of bit: do readout
        if ((PINB & nNorth) == 0)
        	LEDgrid[18] = 1;   
        
          
         // FOURTH BROADCAST ROW           
         
        NextEventTime += 2;  
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Wait until start time
        if (LEDgrid[1]) 
        	PORTB &= 254;   // Set ComOutputMask pin low, to broadcast a TRUE signal, if the LEDgrid[] pin is high.
        else 
            PORTB |= 1;             
        NextEventTime += 2;
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Midpoint of bit: do readout
        if ((PINB & nSouth) == 0)
        	LEDgrid[5] = 1;   
        
        NextEventTime += 2; 
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Wait until start time
        if (LEDgrid[19]) 
        	PORTB &= 254;   // Set ComOutputMask pin low, to broadcast a TRUE signal, if the LEDgrid[] pin is high.
        else 
            PORTB |= 1;             
        NextEventTime += 2;
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Midpoint of bit: do readout
        if ((PINB & nSouth) == 0)
        	LEDgrid[23] = 1;   
                     
          // Southest-Moving Command Broadcast & receive: 3 bits
                    
                             
        OutputCmdSEn= 0;  // Received value: 0 so far.
        OutputCmdSEw= 0;
        
        NextEventTime += 2;  
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Wait until start time
        if (OutputCmdSELast & 1) 
        	PORTB &= 254;   // Set ComOutputMask pin low, to broadcast a TRUE signal
        else 
            PORTB |= 1;                                 
        NextEventTime += 2;
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Midpoint of bit: do readout
        
        if ((PINB & nNorth) == 0)
	        OutputCmdSEn |= 1;   
        if ((PINB & nWest) == 0)
	        OutputCmdSEw |= 1;   
        
        
        NextEventTime += 2;  
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Wait until start time
        if (OutputCmdSELast & 2) 
        	PORTB &= 254;   // Set ComOutputMask pin low, to broadcast a TRUE signal
        else 
            PORTB |= 1;             
        NextEventTime += 2;
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Midpoint of bit: do readout
        if ((PINB & nNorth) == 0)
	        OutputCmdSEn |= 2;   
        if ((PINB & nWest) == 0)
	        OutputCmdSEw |= 2;   
        
                    
        NextEventTime += 2;  
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Wait until start time
        if (OutputCmdSELast & 4) 
        	PORTB &= 254;   // Set ComOutputMask pin low, to broadcast a TRUE signal
        else 
            PORTB |= 1;             
        NextEventTime += 2;
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Midpoint of bit: do readout
        if (((PINB & nNorth) == 0) || ((PINB & nWest) == 0))
        if ((PINB & nNorth) == 0)
            OutputCmdSEn |= 4;   
        if ((PINB & nWest) == 0)
	        OutputCmdSEw |= 4;                          
        
        
        if (OutputCmdSEw > OutputCmdSEn) 		// Pick LARGER of the two "southeast" commands to relay.
            OutputCmdSE = OutputCmdSEw;
        else 
            OutputCmdSE = OutputCmdSEn;
         
        
        
        
        OutputCmdSELast = OutputCmdSE;  // Will retransmit this value next time, unless we receive direct commands otherwise.
        
        NextEventTime += 2;  
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Wait until end of bit transmission            
        PORTB |= 1;   //    // Set ComOutputMask pin high, to broadcast a FALSE signal        
    
                    
       // Time now:  14 + 28*2 = 14 + 4*(12+3) = 74 ticks, or 1184 us after resetting TCNT1.          
                    
        if (ControlBoard == 0)  {
       if (OutputCmdNW == 1)  // STEP action
            { 
                    /* 
                     Any live cell with fewer than two live neighbours dies, as if caused by under-population.
                     Any live cell with more than three live neighbours dies, as if by overcrowding.
                     Any live cell with two or three live neighbours lives on to the next generation.
                     Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.
                     */
                    
                    // Loops are unrolled.  
                    // Why? Fast.  Also, we generally have more program space than RAM for lists. :P
                     
                      
                    i  = LEDgrid[0];
                    i += LEDgrid[1];
                    i += LEDgrid[2];
                    i += LEDgrid[8];
                    i += LEDgrid[14];
                    i += LEDgrid[13];
                    i += LEDgrid[12];
                    i += LEDgrid[6];
                    
                
                NewLEDstate = 0;
                    if (i == 2) 
                    NewLEDstate = (LEDstate & 1);	// No change: if LED 0 was on, leave it on.
                    else if (i == 3) 
                    NewLEDstate = 1;	// becomes live if it wasn't. 
                    
                    
                    //( else, it stays DEAD, because we initialized the array to zero.)
                    
                    i  = LEDgrid[1];
                    i += LEDgrid[2];
                    i += LEDgrid[3];
                    i += LEDgrid[9];
                    i += LEDgrid[15];
                    i += LEDgrid[14];
                    i += LEDgrid[13];
                    i += LEDgrid[7];
                    
                    if (i == 2) 
                    NewLEDstate |= (LEDstate & 2); // no change to PD1
                    else if (i == 3) 
                    NewLEDstate |= 2;	// becomes live if it wasn't. 
                    
                    
                    i  = LEDgrid[2];
                    i += LEDgrid[3];
                    i += LEDgrid[4];
                    i += LEDgrid[10];
                    i += LEDgrid[16];
                    i += LEDgrid[15];
                    i += LEDgrid[14];
                    i += LEDgrid[8];
                    
                    if (i == 2) 
                    NewLEDstate |= (LEDstate & 4); // no change to PD2
                    else if (i == 3) 
                    NewLEDstate |= 4;	// becomes live if it wasn't. 
                    
                    
                    i  = LEDgrid[3];
                    i += LEDgrid[4];
                    i += LEDgrid[5];
                    i += LEDgrid[11];
                    i += LEDgrid[17];
                    i += LEDgrid[16];
                    i += LEDgrid[15];
                    i += LEDgrid[9];
                    
                    if (i == 2) 
                    NewLEDstate |= (LEDstate & 8); // no change to PD3
                    else if (i == 3) 
                    NewLEDstate |= 8;	// becomes live if it wasn't. 
                    
                    
                    i  = LEDgrid[6];
                    i += LEDgrid[7];
                    i += LEDgrid[8];
                    i += LEDgrid[14];
                    i += LEDgrid[20];
                    i += LEDgrid[19];
                    i += LEDgrid[18];
                    i += LEDgrid[12];
                    
                    if (i == 2) 
                    NewLEDstate |= (LEDstate & 16); // no change to PD4
                    else if (i == 3) 
                    NewLEDstate |= 16;	// becomes live if it wasn't. 
                    
                    
                    i  = LEDgrid[7];
                    i += LEDgrid[8];
                    i += LEDgrid[9];
                    i += LEDgrid[15];
                    i += LEDgrid[21];
                    i += LEDgrid[20];
                    i += LEDgrid[19];
                    i += LEDgrid[13];
                    
                    if (i == 2) 
                    NewLEDstate |= (LEDstate & 32); // no change to PD5
                    else if (i == 3) 
                    NewLEDstate |= 32;	// becomes live if it wasn't. 
                    
                    
                    i  = LEDgrid[8];
                    i += LEDgrid[9];
                    i += LEDgrid[10];
                    i += LEDgrid[16];
                    i += LEDgrid[22];
                    i += LEDgrid[21];
                    i += LEDgrid[20];
                    i += LEDgrid[14];
                    
                    if (i == 2) 
                    NewLEDstate |= (LEDstate & 64); // no change to PD6
                    else if (i == 3) 
                    NewLEDstate |= 64;	// becomes live if it wasn't. 
                    
                    
                    i  = LEDgrid[9];
                    i += LEDgrid[10];
                    i += LEDgrid[11];
                    i += LEDgrid[17];
                    i += LEDgrid[23];
                    i += LEDgrid[22];
                    i += LEDgrid[21];
                    i += LEDgrid[15];
                    
                    if (i == 2) 
                    NewLEDstate |= (LEDstate & 128); // no change to PD7
                    else if (i == 3) 
                    NewLEDstate |= 128;	// becomes live if it wasn't. 
                     
                    LEDstate = NewLEDstate; 
                      
                
                
                
                if ((LEDstate == LEDstateLast)||(LEDstate == LEDstateLast2))
                    localIdle = 1;
                else 
                    localIdle = 0;
                
                LEDstateLast2 = LEDstateLast;
                LEDstateLast = LEDstate;
                
                
                    }
                    
         if (OutputCmdNW == 2)  // CLEAR action
                    {
                        i = 0;
                    while (i < 24) {
                    LEDgrid[i] = 0;
                    i++;
                    }
                    
                    LEDstate = 0;
                    
                    }
             
            
   
                    if (OutputCmdNW == 3)  // RANDOM fill
                    { 
                    srand(ADCW);	// Use last ADC result as random seed.
                    LEDstate = (uint8_t) (rand()*109+89);  
                    
                    }
        
        }
                    
        NextEventTime += 30;  // Delay time for preceeding calculations -- 10 ticks? (10 ticks = 160 us = 2560 cycles)    
        
#ifdef DebugAlerts
      if (TCNT1 > NextEventTime) {
          PORTD = 17;		
          while (1) {
              ;;
          }
      } 
#endif
        
        
        if (ControlBoard) {
            
            if (CtrlBlink == 1) {
                CtrlBlink += 1;
            }
            else {
                CtrlBlink = 0;
                LEDstate = 255;
            }              
        }
        
            
             
        
        
        while (TCNT1 < NextEventTime) {  asm("nop");   }  // Short delay before beginning 
              
         // :::UPDATE LEDs WITH NEW STATE INFORMATION::: //         
        PORTD =  LEDstate;      
     //   OutputCmdNW = 0;
            
                    
        // :::ADC READOUT - HUMAN INTERACTION::: //         
             
        
        // Do 7 scans, each of which consists of 16 scans through each sensor, bright and dark.
        uint8_t scannumber = 0;
        
        
        
        
        //   SignalMax[0] = 0;
        //   SignalMin[0] = 0;
        //   SignalMinNew[0] = 0;
        // SignalMinCycleCount
         
        
        SignalMinCycleCount++;
        
        if (SignalMinCycleCount > 240) {
            SignalMinCycleCount = 0;
            
            i = 0;
			while (i < 8) {
                
                SignalMin[i] = SignalMinNew[i];
                SignalMinNew[i] = SignalMax[i];

                i++;   
            }
        }
        
        
        
        while (scannumber < 7) {
            DoADCscan();
  
//            NextEventTime += 4;   // Calculation Delay  
            NextEventTime += 10;   // Calculation Delay  
        
            i = 0;
			while (i < 8) {
				 
				tempInt = (BrightScanTotal[i] >> 1) - (DarkScanTotal[i] >> 1);
                
                if (tempInt < 0) {
                    tempInt = 0;
                }
                  
                if (tempInt > SignalMax[i] ) {
                    SignalMax[i] = tempInt;		// Saves highest signal ever
                }
                 
                if (tempInt < SignalMin[i] ) {
                    SignalMin[i] = tempInt;     //If this signal is lower than the current bottom, use it.
                }    
                
                if (tempInt < SignalMinNew[i] ) {
                    SignalMinNew[i] = tempInt;  //Look at lowest signal in the LAST MINUTE ONLY.
                }    
                 
                
                if(initialized[i]){
                
                    //    thresholdHigh = SignalMin[i] + ((SignalMax[i] - SignalMin[i]) >> 3);  // Top 7/8 of signal range
                    //    thresholdLow = SignalMin[i] + ((SignalMax[i] - SignalMin[i]) >> 3);   // Bottom 12% of signal range
                    
                    thresholdHigh = SignalMin[i] + ((SignalMax[i] - SignalMin[i]) >> 2);  // Top 3/4 of signal range
                    thresholdLow = SignalMin[i] + ((SignalMax[i] - SignalMin[i]) >> 3);   // Bottom 12% of signal range
                    
                    
                    if (tempInt >= thresholdHigh) 
                    {
                        
                        if (DebounceCounter[i] >= 0) {
                            DebounceCounter[i] += 1;
                        } 
                        
                        if (DebounceCounter[i] > 100)		// Prevent overflow. 
                            DebounceCounter[i] = 100;
                        
                        SignalMinCycleCount = 0;  // Backgrounds only collected while idle (on this cell)
                         
                    } 
                    
                    
                    if (tempInt <= thresholdLow) 
                    {
                         
                        
                        // Debounce routine: Require signal level to go below LOW threshold before counting signal again.
                        
                        if (DebounceCounter[i] < 0) {
                            DebounceCounter[i] += 1;
                        } 
                        
                        // Raises signal back up to zero, to complete debounce cycle.
                        
                    }  
                }
                    else{  // NOT initialized
                        
                       if (tempInt >  (SignalLevel[i] + 5)) {
                           DebounceCounter[i] += 1;
                           
                           if (DebounceCounter[i] > 5) {
                               initialized[i] = 1; 
                           } 
                           
                       } 
                        else {
                            DebounceCounter[i]= 0;
                        }
 
                        
                    }
                    
 SignalLevel[i] = tempInt;
                
                
				i++;
			} 
            
            
            
            
            // Need to go through again, now that we've calculated the DebounceCounter value for *all* of the inputs:
            
            DriftSequenceLength = 2;  // How long does signal have to be above threshold?  Value of 4: 4/28 of 1 second, or 0.14 s.  (Was: 1)
            DebounceDuration = 14;		// How long does signal need to be below low-threshold to reactivate? (14: 1/2 second)
            
            DebounceDuration = 0 - DebounceDuration;
            
            
                if (ControlBoard) {
                       
                    tmp = 0;
                    tmp2 = 0;
                      
                    if ((DebounceCounter[0] > DriftSequenceLength)  && (initialized[0]))
                        tmp++;
                    if ((DebounceCounter[1] > DriftSequenceLength)  && (initialized[1]))
                        tmp++;       
                    if ((DebounceCounter[4] > DriftSequenceLength)  && (initialized[4]))
                        tmp++;
                    if ((DebounceCounter[5] > DriftSequenceLength)  && (initialized[5]))
                        tmp++;
                    
                    if ((DebounceCounter[2] > DriftSequenceLength)  && (initialized[2]))
                        tmp2++;
                    if ((DebounceCounter[3] > DriftSequenceLength)  && (initialized[3]))
                        tmp2++;       
                    if ((DebounceCounter[6] > DriftSequenceLength)  && (initialized[6]))
                        tmp2++;
                    if ((DebounceCounter[7] > DriftSequenceLength)  && (initialized[7]))
                        tmp2++;                
                    
                    
                    
                    if (tmp > 0) {
                        
                        i = 0;
                        while (i < 8) {
                        DebounceCounter[i] =  DebounceDuration ;
                        i++;
                        }
                        
                        LEDstate &= 204;   // 4+8+64+128
                        CtrlBlink = 1;
                        
                        
                        // SE Going Commands: Execute in order of higher numbers
                        // 0: No action
                        // 1: Report Idle Condition
                        // 2: Clear
                        // 3: Rand
                        // 4: Pause
                        // 5: Play (run)
                        // 6: Step
                        
                        
                         
                        if (BoardType == 1) {		// Step-Play Board
                            OutputCmdSELast = 6; // STEP        
                            }    
                        if (BoardType == 2) {		// Pause-Clear Board
                                 OutputCmdSELast = 4; // Pause    
                            }    
                        
                         
                        
                        
                    }  
     
                    if (tmp2 > 0) {
                        
                        i = 0;
                        while (i < 8) {
                            DebounceCounter[i] =  DebounceDuration;
                            i++;
                        }
                        
                        LEDstate &= 51; //1 + 2 + 16 + 32
                        CtrlBlink = 1;
                        
                        
                        if (BoardType == 1) {		// Step-Play Board
                             OutputCmdSELast = 5; // RUN (Play)             
                        }    
                        if (BoardType == 2) {		// Pause-Clear Board
                            OutputCmdSELast = 2; // CLEAR       
                        }    
                        
                             
                        
                    }  
                       
                    
                }
                else {  // Single input activated
                    
                    
                    i = 0;
                    while (i < 8) {   
                        
                        if(initialized[i]){
                    if (DebounceCounter[i] > DriftSequenceLength)  {   
                        DebounceCounter[i] = DebounceDuration; 
                        
                        tmp = 1 << i;
                        
                        if (LEDstate & tmp) {
                            LEDstate &= ~tmp;
                        }
                        else {
                            LEDstate |= tmp;
                        } 
                    	}   
                         
                        }
                        
                        i++;
                } 
            } 
             
            
            
            scannumber++;
        }
        
        
        
         PORTD = LEDstate;
        
         
        
        
        // End of cycle housekeeping:
        
        
         
        
        
        
        
        
        // MASTER BOARD OPTIONS
        if (BoardRank == 1) {	// If this is the Master board
            
            OutputCmdNW = 0;
            
            // NE Going Commands: 
            // 0: No action
            // 1: Step
            // 2: Clear
            // 3: Rand
            
            // SE Going Commands: Execute in order of higher numbers
            // 0: No action
            // 1: Report Idle Condition
            // 2: Clear
            // 3: Rand  
            // 4: Pause
            // 5: Play (run)  -- increase speed mode
            // 6: Step
            
            
            if (OutputCmdSELast == 1) {
                
                
                
                // Random Fill Config: 0: After 60 s idle.  1: After 15 s idle.  2: Disabled. 
                
                
                if (RandomConfig < 2) {
                    
                    if (RunMode) {
                        idleCount++;
                    } 
                    
	                if (RandomConfig == 0)
                        tmp = 240;
                    else 
                        tmp = 60;
                     
	                if (idleCount > tmp) {  //240:  If IDLE in RUN mode for 60 seconds...
                            idleCount = 0; 
                            OutputCmdNW = 3;   // Send RAND command      
                        }
   
                }
                
                
                 
                
                
            }
            else {
                idleCount = 0;		// Set to zero when NO idle command received!
            }
            
            
            if (OutputCmdSELast > 0) {
                // There are incoming commands to process.
                
                if (OutputCmdSELast == 6) {
                    RunMode = 0;    // Pause
                    OutputCmdNW = 1; // Step Now
                }                    
                
                if (OutputCmdSELast == 5) {
                    
                    if (RunMode) {
                        
                        StepSpeed++;
                        if (StepSpeed > 2) {
                            StepSpeed = 0;   // Cycle back to low speed
                        }
                    }
                    else {
                        RunMode = 1; // Begin running
					//	StepSpeed = 0;
                    }
                    
                }
                
                if (OutputCmdSELast == 4) {
                    RunMode = 0;   // Pause
                }              
                
                if (OutputCmdSELast == 3) {
                    OutputCmdNW = 3;   // Send RAND command
                }    
                
                if (OutputCmdSELast == 2) {
                    OutputCmdNW = 2;   // Send CLEAR command
                }          
  
                OutputCmdSELast = 0;  // No need to transmit this value further SE.
            }
           
            
            if (RunMode) {
                RunMode++;
                
                if (StepSpeed) {
                    tmp = 2;
                    
                    if (StepSpeed == 2) {
                        tmp = 1;
                    }
                }
                else {
                    tmp = 4;
                }

                
                if (RunMode > tmp) {
                    
                    if (OutputCmdNW == 0) {	// STEP does NOT take priority over other commands (incl. rand, clear!).
                        OutputCmdNW = 1; // Step Now		
                        RunMode = 1;
                    }
           else
           	RunMode = 16;  // Delay execution of step, when there is another command to process.
                    
                }
            }  
             
        }
        
        

        
        if (BoardRank == 2) {	// The "caboose board"
            if ((OutputCmdSELast == 0) && (localIdle)) {
                OutputCmdSELast = 1; // Initiate "idle condition" transmission.
            }
        }
              
        if (OutputCmdSELast == 1) { // If we have received an incoming "Idle" condition...
            if (localIdle == 0) {	// and if THIS board is not idle, then
                OutputCmdSELast = 0; // block the "idle condition" transmission.

            }
        }         
        
        
         
        
        
        
        
        
        // Check to see if button was pressed during this last cycle:
        
        if (buttonMonitor == 0) {
            
            if ( PINB & _BV(5)) 
            {  // Special case, for quicker UI response.
                // The button WAS down at some point in the last 1/4 second,
                // AND the button has been released since then,
                // AND it has not already been detected to be down for a full second,
                // Then indicate a simple press has occurred:
                
                if (waitforrelease == 0){
                	buttonMonitor = 1;  
                    buttonMonitorLast = 0;  
                }
            }
        }

        
         
        
        
        if ((buttonMonitor == 0) && (buttonMonitorLast)) {
            // Button was just pressed.
             
            buttonTimer = 0;
            waitforrelease = 0;
        }
        
        if ((buttonMonitor == 0) && (buttonMonitorLast == 0)) {
            
             // Button has been held down for AT LEAST .25 s.
            if (buttonTimer < 200)
                buttonTimer++;
            
           
            if (buttonTimer > 3) { // Held for at least 1 s. 
                
                if (waitforrelease == 0) { 
                    waitforrelease = 1;	 
                     
				if ( BoardRank == 1 )	// Master board
                {
                     OutputCmdNW = 2;   // Send CLEAR command
                     //StepSpeed = 0; // go to slow speed, too.
                   }
                else 					// Non-master board
                    OutputCmdSELast = 3;	// Send RAND command, SE.
                
    
                    
                }
            }  
        }        
         
        if ((buttonMonitor == 1) && (buttonMonitorLast == 0)){
            
            // Button just released
            
            if (waitforrelease == 0) {
                //If we were waiting for the button to be released, then we have ALREADY acted on its being held down.
                //So, do not do anything.
                //But, if the button were released sooner than 1 second after being pressed, let's act on it:
                  
                
                // Short-press button commmands:
                if ( BoardRank == 1 )	// Master board
                    
                {if (RunMode > 0) 
                {
                    RunMode = 0;  // Leave at full speed.
                }   
                    
                    else	
                RunMode = 1; 	// Play/pause on single button press
                
                } 
                else 					// Non-master board
                    OutputCmdSELast = 5; // RUN (Play) -- Set Speed Mode
                
                
            } 
            waitforrelease = 0;
        }
        
        
         
        buttonMonitorLast = buttonMonitor;
        buttonMonitor = 1;
        
        
        
        
        
        
        
       if( BoardRank == 1 )
       {
           // Master board!
           
           while (TCNT1 < 15624)		// 250 ms
           {  asm("nop");   }
           TCNT1 = 0;	// Set counter value at 0 to begin with.
           PORTB &= 254;   // Set ComOutputMask pin low; broadcast zero. 
           
       }   
        else
    	  {
              
              
              while ((PINB & ComInputMaskSE) == ComInputMaskSE)
              
              {
				#ifdef DebugAlerts
                  if (TCNT1 > 16000) {		// Should never get here!
                      PORTD = 1+4+32+128;
                      while (1) {
                          ;;
                      }
                  } 
				#endif
              
                           
                 
              }
              
              TCNT1 = 0;	// Set counter value at 0 to begin cycle.
              PORTB &= 254;   // Set ComOutputMask pin low; broadcast zero. 
              
              
                    }       
                    
// Loop should ALWAYS end by 255 ms on TCNT1, 15938 ticks.		
		 
		
	}// End infinite loop
} // end  loop() 

  
                    /*
                    
                    SIGNAL(SIG_PIN_CHANGE1)	
                    { 
                    
                    TCNT1 = 0;	// Set counter value at 0 to begin with.
                    PORTB &= 254;   // Set ComOutputMask pin low; broadcast zero. 
                    
                    }
                    */


